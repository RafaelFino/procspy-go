
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>domain: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">procspy/internal/procspy/domain/command.go (76.5%)</option>
				
				<option value="file1">procspy/internal/procspy/domain/match.go (76.5%)</option>
				
				<option value="file2">procspy/internal/procspy/domain/target.go (91.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package domain

import (
        "encoding/json"
        "log"
        "time"
)

type Command struct {
        User        string    `json:"user"`
        Name        string    `json:"name"`
        CommandLine string    `json:"command_line"`
        Return      string    `json:"command_return"`
        Source      string    `json:"source"`
        CommandLog  string    `json:"command_log"`
        CreatedAt   time.Time `json:"created_at,omitempty"`
}

func NewCommand(user string, name string, commandLine string, commandReturn string) *Command <span class="cov8" title="1">{
        return &amp;Command{
                User:        user,
                Name:        name,
                CommandLine: commandLine,
                Return:      commandReturn,
                Source:      "procspy",
                CommandLog:  "",
                CreatedAt:   time.Now(),
        }
}</span>

func (c *Command) ToLog() string <span class="cov8" title="1">{
        ret, err := json.Marshal(c)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[domain.Command] Error parsing json: %s", err)
                return ""
        }</span>
        <span class="cov8" title="1">return string(ret)</span>
}
func (c *Command) ToJson() string <span class="cov8" title="1">{
        ret, err := json.MarshalIndent(c, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[domain.Command] Error parsing json: %s", err)
                return ""
        }</span>
        <span class="cov8" title="1">return string(ret)</span>
}

func CommandFromJson(jsonString string) (*Command, error) <span class="cov8" title="1">{
        ret := &amp;Command{}
        err := json.Unmarshal([]byte(jsonString), ret)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("[domain.Command] Error parsing json: %s", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package domain

import (
        "encoding/json"
        "log"
        "time"
)

type Match struct {
        User       string    `json:"user"`
        Name       string    `json:"name"`
        Pattern    string    `json:"pattern"`
        Match      string    `json:"match"`
        Elapsed    float64   `json:"elapsed"`
        CreatedAt  time.Time `json:"created_at,omitempty"`
        FirstMatch string    `json:"first_match,omitempty"`
        LastMatch  string    `json:"last_match,omitempty"`
        Ocurrences int       `json:"ocurrences,omitempty"`
}

type MatchList struct {
        Matches map[string]float64 `json:"matches"`
}

type MatchInfo struct {
        Elapsed    float64 `json:"elapsed"`
        FirstMatch string  `json:"first_match"`
        LastMatch  string  `json:"last_match"`
        Ocurrences int     `json:"ocurrences"`
}

func NewMatch(user string, name string, pattern string, match string, elapsed float64) *Match <span class="cov8" title="1">{
        ret := &amp;Match{
                User:      user,
                Name:      name,
                Pattern:   pattern,
                Match:     match,
                Elapsed:   elapsed,
                CreatedAt: time.Now(),
        }

        return ret
}</span>

func (m *Match) ToLog() string <span class="cov8" title="1">{
        ret, err := json.Marshal(m)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[domain.Match] Error parsing json: %s", err)
                return ""
        }</span>
        <span class="cov8" title="1">return string(ret)</span>
}

func (m *Match) ToJson() string <span class="cov8" title="1">{
        ret, err := json.MarshalIndent(m, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[domain.Match] Error parsing json: %s", err)
                return ""
        }</span>
        <span class="cov8" title="1">return string(ret)</span>
}

func MatchFromJson(jsonString string) (*Match, error) <span class="cov8" title="1">{
        ret := &amp;Match{}
        err := json.Unmarshal([]byte(jsonString), ret)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("[domain.Match] Error parsing json: %s", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return ret, nil</span>
}

func MatchListFromJson(jsonString string) (*MatchList, error) <span class="cov8" title="1">{
        ret := &amp;MatchList{}
        err := json.Unmarshal([]byte(jsonString), &amp;ret)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("[domain.Match] Error parsing json: %s", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func (m *MatchInfo) ToJson() string <span class="cov8" title="1">{
        ret, err := json.MarshalIndent(m, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[domain.Match] Error parsing json: %s", err)
                return ""
        }</span>
        <span class="cov8" title="1">return string(ret)</span>
}

func (m *MatchInfo) ToLog() string <span class="cov8" title="1">{
        ret, err := json.Marshal(m)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[domain.Match] Error parsing json: %s", err)
                return ""
        }</span>
        <span class="cov8" title="1">return string(ret)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package domain

import (
        "encoding/json"
        "fmt"
        "log"
        "regexp"
        "time"
)

const DEFAULT_WEEKDAY_LIMIT = 0.5
const DEFAULT_WEEKEND_LIMIT = 1.0
const DEFAULT_BASE_LIMIT = 60 * 60
const DEFAULT_WARNING_ON = 0.95

type Target struct {
        User           string          `json:"user"`
        Name           string          `json:"name"`
        Pattern        string          `json:"pattern"`
        Source         string          `json:"source,omitempty"`
        Limit          float64         `json:"limit"`
        Elapsed        float64         `json:"elapsed,omitempty"`
        Remaining      float64         `json:"remaining"`
        Ocurrences     int             `json:"ocurrences,omitempty"`
        FirstMatch     string          `json:"first_match,omitempty"`
        LastMatch      string          `json:"last_match,omitempty"`
        Kill           bool            `json:"kill"`
        LimitCommand   string          `json:"limit_command,omitempty"`
        CheckCommand   string          `json:"check_command,omitempty"`
        WarningCommand string          `json:"warning_command,omitempty"`
        WarningOn      float64         `json:"warning_on,omitempty"`
        Weekdays       map[int]float64 `json:"weekdays,omitempty"`
        rgx            *regexp.Regexp
}

func (t *Target) setWeekdays() <span class="cov8" title="1">{
        if t.Weekdays == nil </span><span class="cov8" title="1">{
                t.Weekdays = map[int]float64{}
        }</span>

        <span class="cov8" title="1">for i := range 7 </span><span class="cov8" title="1">{
                if _, found := t.Weekdays[i]; !found </span><span class="cov8" title="1">{
                        if i == 0 || i == 6 </span><span class="cov8" title="1">{
                                t.Weekdays[i] = DEFAULT_WEEKEND_LIMIT
                        }</span> else<span class="cov8" title="1"> {
                                t.Weekdays[i] = DEFAULT_WEEKDAY_LIMIT
                        }</span>
                }
        }
}

func (t *Target) ToLog() string <span class="cov8" title="1">{
        ret, err := json.Marshal(t)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[domain.Target] Error parsing json: %s", err)
                return ""
        }</span>
        <span class="cov8" title="1">return string(ret)</span>
}
func (t *Target) ToJson() string <span class="cov8" title="1">{
        ret, err := json.MarshalIndent(t, "", "\t")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[domain.Target] Error parsing json: %s", err)
        }</span>

        <span class="cov8" title="1">return string(ret)</span>
}

type TargetList struct {
        Targets []*Target `json:"targets"`
}

func NewTargetList() *TargetList <span class="cov8" title="1">{
        return &amp;TargetList{
                Targets: []*Target{},
        }
}</span>

func TargetListFromJson(jsonString string) (*TargetList, error) <span class="cov8" title="1">{
        ret := &amp;TargetList{}
        err := json.Unmarshal([]byte(jsonString), ret)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("[domain.Target] Error parsing json: %s", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, v := range ret.Targets </span><span class="cov8" title="1">{
                v.setWeekdays()
                v.getLimit()
        }</span>

        <span class="cov8" title="1">return ret, nil</span>
}

func (t *TargetList) ToLog() string <span class="cov8" title="1">{
        ret, err := json.MarshalIndent(t, "", "\t")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[domain.TargetList] Error parsing json: %s", err)
                return ""
        }</span>
        <span class="cov8" title="1">return string(ret)</span>
}

func (t *TargetList) Hash() string <span class="cov8" title="1">{
        ret := ""
        for _, v := range t.Targets </span><span class="cov8" title="1">{
                ret += fmt.Sprintf("%s %s %s %f %f %t %s %s %s %s", v.User, v.Name, v.Pattern, v.getLimit(), v.getWarningOn(), v.Kill, v.Source, v.CheckCommand, v.WarningCommand, v.LimitCommand)
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (t *Target) Match(value string) bool <span class="cov8" title="1">{
        if t.rgx == nil </span><span class="cov8" title="1">{
                t.rgx = regexp.MustCompile(t.Pattern)
        }</span>

        <span class="cov8" title="1">ret := t.rgx.MatchString(value)

        return ret</span>
}

func (t *Target) AddMatchInfo(info *MatchInfo) <span class="cov8" title="1">{
        t.Elapsed += info.Elapsed
        t.FirstMatch = info.FirstMatch
        t.LastMatch = info.LastMatch
        t.Ocurrences = info.Ocurrences
        t.Remaining = t.getLimit() - t.Elapsed
}</span>

func (t *Target) AddElapsed(elapsed float64) <span class="cov8" title="1">{
        t.Elapsed += elapsed
        t.Remaining = t.getLimit() - t.Elapsed
}</span>

func (t *Target) SetElapsed(elapsed float64) <span class="cov8" title="1">{
        t.Elapsed = elapsed
        t.Remaining = t.getLimit() - elapsed
}</span>

func (t *Target) ResetElapsed() <span class="cov8" title="1">{
        t.Elapsed = 0
        t.Remaining = t.getLimit()
}</span>

func (t *Target) CheckLimit() bool <span class="cov8" title="1">{
        limit := t.getLimit()
        if limit == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return t.Elapsed &gt;= limit</span>
}

func (t *Target) CheckWarning() bool <span class="cov8" title="1">{
        warn := t.getWarningOn()
        if warn == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return t.Elapsed &gt; warn</span>
}

func (t *Target) getLimit() float64 <span class="cov8" title="1">{
        today := int(time.Now().Weekday())

        factor, found := t.Weekdays[today]

        if !found </span><span class="cov8" title="1">{
                factor = DEFAULT_WEEKDAY_LIMIT
        }</span>

        <span class="cov8" title="1">t.Limit = DEFAULT_BASE_LIMIT * factor
        if t.Remaining &lt;= 0 </span><span class="cov8" title="1">{
                t.Remaining = t.Limit
        }</span>

        <span class="cov8" title="1">return t.Limit</span>
}

func (t *Target) getWarningOn() float64 <span class="cov8" title="1">{
        t.WarningOn = t.getLimit() * DEFAULT_WARNING_ON
        return t.WarningOn
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
